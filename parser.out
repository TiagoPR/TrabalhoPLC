Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    E
    ELSE
    FALSE
    IF
    INF
    INFEQ
    OU
    PRINT
    SUP
    SUPEQ
    THEN
    TRUE
    WHILE

Grammar

Rule 0     S' -> Programa
Rule 1     Programa -> Funcs Vars Cod
Rule 2     Vars -> <empty>
Rule 3     Vars -> var Vars
Rule 4     Funcs -> <empty>
Rule 5     Funcs -> Funcs Func
Rule 6     Func -> ID begin Cod return expr end
Rule 7     Cod -> <empty>
Rule 8     var -> INT ID .
Rule 9     var -> INT ID = expr .
Rule 10    Cod -> Linha Cod
Rule 11    Linha -> atr
Rule 12    Linha -> Ler
Rule 13    Ler -> INPUT FRASE
Rule 14    expr -> expr + termo
Rule 15    expr -> expr - termo
Rule 16    expr -> termo
Rule 17    termo -> termo * fator
Rule 18    termo -> termo / fator
Rule 19    termo -> fator
Rule 20    fator -> NUM
Rule 21    fator -> ID
Rule 22    fator -> ( expr )
Rule 23    atr -> ID = expr

Terminals, with rules where they appear

(                    : 22
)                    : 22
*                    : 17
+                    : 14
-                    : 15
.                    : 8 9
/                    : 18
=                    : 9 23
DO                   : 
E                    : 
ELSE                 : 
FALSE                : 
FRASE                : 13
ID                   : 6 8 9 21 23
IF                   : 
INF                  : 
INFEQ                : 
INPUT                : 13
INT                  : 8 9
NUM                  : 20
OU                   : 
PRINT                : 
SUP                  : 
SUPEQ                : 
THEN                 : 
TRUE                 : 
WHILE                : 
begin                : 6
end                  : 6
error                : 
return               : 6

Nonterminals, with rules where they appear

Cod                  : 1 6 10
Func                 : 5
Funcs                : 1 5
Ler                  : 12
Linha                : 10
Programa             : 0
Vars                 : 1 3
atr                  : 11
expr                 : 6 9 14 15 22 23
fator                : 17 18 19
termo                : 14 15 16 17 18
var                  : 3

Parsing method: LALR

state 0

    (0) S' -> . Programa
    (1) Programa -> . Funcs Vars Cod
    (4) Funcs -> .
    (5) Funcs -> . Funcs Func

    ID              reduce using rule 4 (Funcs -> .)
    INT             reduce using rule 4 (Funcs -> .)
    INPUT           reduce using rule 4 (Funcs -> .)
    $end            reduce using rule 4 (Funcs -> .)

    Programa                       shift and go to state 1
    Funcs                          shift and go to state 2

state 1

    (0) S' -> Programa .



state 2

    (1) Programa -> Funcs . Vars Cod
    (5) Funcs -> Funcs . Func
    (2) Vars -> .
    (3) Vars -> . var Vars
    (6) Func -> . ID begin Cod return expr end
    (8) var -> . INT ID .
    (9) var -> . INT ID = expr .

  ! shift/reduce conflict for ID resolved as shift
    INPUT           reduce using rule 2 (Vars -> .)
    $end            reduce using rule 2 (Vars -> .)
    ID              shift and go to state 6
    INT             shift and go to state 7

  ! ID              [ reduce using rule 2 (Vars -> .) ]

    Vars                           shift and go to state 3
    Func                           shift and go to state 4
    var                            shift and go to state 5

state 3

    (1) Programa -> Funcs Vars . Cod
    (7) Cod -> .
    (10) Cod -> . Linha Cod
    (11) Linha -> . atr
    (12) Linha -> . Ler
    (23) atr -> . ID = expr
    (13) Ler -> . INPUT FRASE

    $end            reduce using rule 7 (Cod -> .)
    ID              shift and go to state 12
    INPUT           shift and go to state 13

    Cod                            shift and go to state 8
    Linha                          shift and go to state 9
    atr                            shift and go to state 10
    Ler                            shift and go to state 11

state 4

    (5) Funcs -> Funcs Func .

    ID              reduce using rule 5 (Funcs -> Funcs Func .)
    INT             reduce using rule 5 (Funcs -> Funcs Func .)
    INPUT           reduce using rule 5 (Funcs -> Funcs Func .)
    $end            reduce using rule 5 (Funcs -> Funcs Func .)


state 5

    (3) Vars -> var . Vars
    (2) Vars -> .
    (3) Vars -> . var Vars
    (8) var -> . INT ID .
    (9) var -> . INT ID = expr .

    ID              reduce using rule 2 (Vars -> .)
    INPUT           reduce using rule 2 (Vars -> .)
    $end            reduce using rule 2 (Vars -> .)
    INT             shift and go to state 7

    var                            shift and go to state 5
    Vars                           shift and go to state 14

state 6

    (6) Func -> ID . begin Cod return expr end

    begin           shift and go to state 15


state 7

    (8) var -> INT . ID .
    (9) var -> INT . ID = expr .

    ID              shift and go to state 16


state 8

    (1) Programa -> Funcs Vars Cod .

    $end            reduce using rule 1 (Programa -> Funcs Vars Cod .)


state 9

    (10) Cod -> Linha . Cod
    (7) Cod -> .
    (10) Cod -> . Linha Cod
    (11) Linha -> . atr
    (12) Linha -> . Ler
    (23) atr -> . ID = expr
    (13) Ler -> . INPUT FRASE

    $end            reduce using rule 7 (Cod -> .)
    return          reduce using rule 7 (Cod -> .)
    ID              shift and go to state 12
    INPUT           shift and go to state 13

    Linha                          shift and go to state 9
    Cod                            shift and go to state 17
    atr                            shift and go to state 10
    Ler                            shift and go to state 11

state 10

    (11) Linha -> atr .

    ID              reduce using rule 11 (Linha -> atr .)
    INPUT           reduce using rule 11 (Linha -> atr .)
    $end            reduce using rule 11 (Linha -> atr .)
    return          reduce using rule 11 (Linha -> atr .)


state 11

    (12) Linha -> Ler .

    ID              reduce using rule 12 (Linha -> Ler .)
    INPUT           reduce using rule 12 (Linha -> Ler .)
    $end            reduce using rule 12 (Linha -> Ler .)
    return          reduce using rule 12 (Linha -> Ler .)


state 12

    (23) atr -> ID . = expr

    =               shift and go to state 18


state 13

    (13) Ler -> INPUT . FRASE

    FRASE           shift and go to state 19


state 14

    (3) Vars -> var Vars .

    ID              reduce using rule 3 (Vars -> var Vars .)
    INPUT           reduce using rule 3 (Vars -> var Vars .)
    $end            reduce using rule 3 (Vars -> var Vars .)


state 15

    (6) Func -> ID begin . Cod return expr end
    (7) Cod -> .
    (10) Cod -> . Linha Cod
    (11) Linha -> . atr
    (12) Linha -> . Ler
    (23) atr -> . ID = expr
    (13) Ler -> . INPUT FRASE

    return          reduce using rule 7 (Cod -> .)
    ID              shift and go to state 12
    INPUT           shift and go to state 13

    Cod                            shift and go to state 20
    Linha                          shift and go to state 9
    atr                            shift and go to state 10
    Ler                            shift and go to state 11

state 16

    (8) var -> INT ID . .
    (9) var -> INT ID . = expr .

    .               shift and go to state 21
    =               shift and go to state 22


state 17

    (10) Cod -> Linha Cod .

    $end            reduce using rule 10 (Cod -> Linha Cod .)
    return          reduce using rule 10 (Cod -> Linha Cod .)


state 18

    (23) atr -> ID = . expr
    (14) expr -> . expr + termo
    (15) expr -> . expr - termo
    (16) expr -> . termo
    (17) termo -> . termo * fator
    (18) termo -> . termo / fator
    (19) termo -> . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    expr                           shift and go to state 24
    termo                          shift and go to state 25
    fator                          shift and go to state 26

state 19

    (13) Ler -> INPUT FRASE .

    ID              reduce using rule 13 (Ler -> INPUT FRASE .)
    INPUT           reduce using rule 13 (Ler -> INPUT FRASE .)
    $end            reduce using rule 13 (Ler -> INPUT FRASE .)
    return          reduce using rule 13 (Ler -> INPUT FRASE .)


state 20

    (6) Func -> ID begin Cod . return expr end

    return          shift and go to state 29


state 21

    (8) var -> INT ID . .

    INT             reduce using rule 8 (var -> INT ID . .)
    ID              reduce using rule 8 (var -> INT ID . .)
    INPUT           reduce using rule 8 (var -> INT ID . .)
    $end            reduce using rule 8 (var -> INT ID . .)


state 22

    (9) var -> INT ID = . expr .
    (14) expr -> . expr + termo
    (15) expr -> . expr - termo
    (16) expr -> . termo
    (17) termo -> . termo * fator
    (18) termo -> . termo / fator
    (19) termo -> . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    expr                           shift and go to state 30
    termo                          shift and go to state 25
    fator                          shift and go to state 26

state 23

    (21) fator -> ID .

    *               reduce using rule 21 (fator -> ID .)
    /               reduce using rule 21 (fator -> ID .)
    +               reduce using rule 21 (fator -> ID .)
    -               reduce using rule 21 (fator -> ID .)
    ID              reduce using rule 21 (fator -> ID .)
    INPUT           reduce using rule 21 (fator -> ID .)
    $end            reduce using rule 21 (fator -> ID .)
    return          reduce using rule 21 (fator -> ID .)
    .               reduce using rule 21 (fator -> ID .)
    )               reduce using rule 21 (fator -> ID .)
    end             reduce using rule 21 (fator -> ID .)


state 24

    (23) atr -> ID = expr .
    (14) expr -> expr . + termo
    (15) expr -> expr . - termo

    ID              reduce using rule 23 (atr -> ID = expr .)
    INPUT           reduce using rule 23 (atr -> ID = expr .)
    $end            reduce using rule 23 (atr -> ID = expr .)
    return          reduce using rule 23 (atr -> ID = expr .)
    +               shift and go to state 31
    -               shift and go to state 32


state 25

    (16) expr -> termo .
    (17) termo -> termo . * fator
    (18) termo -> termo . / fator

    +               reduce using rule 16 (expr -> termo .)
    -               reduce using rule 16 (expr -> termo .)
    ID              reduce using rule 16 (expr -> termo .)
    INPUT           reduce using rule 16 (expr -> termo .)
    $end            reduce using rule 16 (expr -> termo .)
    return          reduce using rule 16 (expr -> termo .)
    .               reduce using rule 16 (expr -> termo .)
    )               reduce using rule 16 (expr -> termo .)
    end             reduce using rule 16 (expr -> termo .)
    *               shift and go to state 33
    /               shift and go to state 34


state 26

    (19) termo -> fator .

    *               reduce using rule 19 (termo -> fator .)
    /               reduce using rule 19 (termo -> fator .)
    +               reduce using rule 19 (termo -> fator .)
    -               reduce using rule 19 (termo -> fator .)
    ID              reduce using rule 19 (termo -> fator .)
    INPUT           reduce using rule 19 (termo -> fator .)
    $end            reduce using rule 19 (termo -> fator .)
    return          reduce using rule 19 (termo -> fator .)
    .               reduce using rule 19 (termo -> fator .)
    )               reduce using rule 19 (termo -> fator .)
    end             reduce using rule 19 (termo -> fator .)


state 27

    (20) fator -> NUM .

    *               reduce using rule 20 (fator -> NUM .)
    /               reduce using rule 20 (fator -> NUM .)
    +               reduce using rule 20 (fator -> NUM .)
    -               reduce using rule 20 (fator -> NUM .)
    ID              reduce using rule 20 (fator -> NUM .)
    INPUT           reduce using rule 20 (fator -> NUM .)
    $end            reduce using rule 20 (fator -> NUM .)
    return          reduce using rule 20 (fator -> NUM .)
    .               reduce using rule 20 (fator -> NUM .)
    )               reduce using rule 20 (fator -> NUM .)
    end             reduce using rule 20 (fator -> NUM .)


state 28

    (22) fator -> ( . expr )
    (14) expr -> . expr + termo
    (15) expr -> . expr - termo
    (16) expr -> . termo
    (17) termo -> . termo * fator
    (18) termo -> . termo / fator
    (19) termo -> . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    expr                           shift and go to state 35
    termo                          shift and go to state 25
    fator                          shift and go to state 26

state 29

    (6) Func -> ID begin Cod return . expr end
    (14) expr -> . expr + termo
    (15) expr -> . expr - termo
    (16) expr -> . termo
    (17) termo -> . termo * fator
    (18) termo -> . termo / fator
    (19) termo -> . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    expr                           shift and go to state 36
    termo                          shift and go to state 25
    fator                          shift and go to state 26

state 30

    (9) var -> INT ID = expr . .
    (14) expr -> expr . + termo
    (15) expr -> expr . - termo

    .               shift and go to state 37
    +               shift and go to state 31
    -               shift and go to state 32


state 31

    (14) expr -> expr + . termo
    (17) termo -> . termo * fator
    (18) termo -> . termo / fator
    (19) termo -> . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    termo                          shift and go to state 38
    fator                          shift and go to state 26

state 32

    (15) expr -> expr - . termo
    (17) termo -> . termo * fator
    (18) termo -> . termo / fator
    (19) termo -> . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    termo                          shift and go to state 39
    fator                          shift and go to state 26

state 33

    (17) termo -> termo * . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    fator                          shift and go to state 40

state 34

    (18) termo -> termo / . fator
    (20) fator -> . NUM
    (21) fator -> . ID
    (22) fator -> . ( expr )

    NUM             shift and go to state 27
    ID              shift and go to state 23
    (               shift and go to state 28

    fator                          shift and go to state 41

state 35

    (22) fator -> ( expr . )
    (14) expr -> expr . + termo
    (15) expr -> expr . - termo

    )               shift and go to state 42
    +               shift and go to state 31
    -               shift and go to state 32


state 36

    (6) Func -> ID begin Cod return expr . end
    (14) expr -> expr . + termo
    (15) expr -> expr . - termo

    end             shift and go to state 43
    +               shift and go to state 31
    -               shift and go to state 32


state 37

    (9) var -> INT ID = expr . .

    INT             reduce using rule 9 (var -> INT ID = expr . .)
    ID              reduce using rule 9 (var -> INT ID = expr . .)
    INPUT           reduce using rule 9 (var -> INT ID = expr . .)
    $end            reduce using rule 9 (var -> INT ID = expr . .)


state 38

    (14) expr -> expr + termo .
    (17) termo -> termo . * fator
    (18) termo -> termo . / fator

    +               reduce using rule 14 (expr -> expr + termo .)
    -               reduce using rule 14 (expr -> expr + termo .)
    ID              reduce using rule 14 (expr -> expr + termo .)
    INPUT           reduce using rule 14 (expr -> expr + termo .)
    $end            reduce using rule 14 (expr -> expr + termo .)
    return          reduce using rule 14 (expr -> expr + termo .)
    .               reduce using rule 14 (expr -> expr + termo .)
    )               reduce using rule 14 (expr -> expr + termo .)
    end             reduce using rule 14 (expr -> expr + termo .)
    *               shift and go to state 33
    /               shift and go to state 34


state 39

    (15) expr -> expr - termo .
    (17) termo -> termo . * fator
    (18) termo -> termo . / fator

    +               reduce using rule 15 (expr -> expr - termo .)
    -               reduce using rule 15 (expr -> expr - termo .)
    ID              reduce using rule 15 (expr -> expr - termo .)
    INPUT           reduce using rule 15 (expr -> expr - termo .)
    $end            reduce using rule 15 (expr -> expr - termo .)
    return          reduce using rule 15 (expr -> expr - termo .)
    .               reduce using rule 15 (expr -> expr - termo .)
    )               reduce using rule 15 (expr -> expr - termo .)
    end             reduce using rule 15 (expr -> expr - termo .)
    *               shift and go to state 33
    /               shift and go to state 34


state 40

    (17) termo -> termo * fator .

    *               reduce using rule 17 (termo -> termo * fator .)
    /               reduce using rule 17 (termo -> termo * fator .)
    +               reduce using rule 17 (termo -> termo * fator .)
    -               reduce using rule 17 (termo -> termo * fator .)
    ID              reduce using rule 17 (termo -> termo * fator .)
    INPUT           reduce using rule 17 (termo -> termo * fator .)
    $end            reduce using rule 17 (termo -> termo * fator .)
    return          reduce using rule 17 (termo -> termo * fator .)
    .               reduce using rule 17 (termo -> termo * fator .)
    )               reduce using rule 17 (termo -> termo * fator .)
    end             reduce using rule 17 (termo -> termo * fator .)


state 41

    (18) termo -> termo / fator .

    *               reduce using rule 18 (termo -> termo / fator .)
    /               reduce using rule 18 (termo -> termo / fator .)
    +               reduce using rule 18 (termo -> termo / fator .)
    -               reduce using rule 18 (termo -> termo / fator .)
    ID              reduce using rule 18 (termo -> termo / fator .)
    INPUT           reduce using rule 18 (termo -> termo / fator .)
    $end            reduce using rule 18 (termo -> termo / fator .)
    return          reduce using rule 18 (termo -> termo / fator .)
    .               reduce using rule 18 (termo -> termo / fator .)
    )               reduce using rule 18 (termo -> termo / fator .)
    end             reduce using rule 18 (termo -> termo / fator .)


state 42

    (22) fator -> ( expr ) .

    *               reduce using rule 22 (fator -> ( expr ) .)
    /               reduce using rule 22 (fator -> ( expr ) .)
    +               reduce using rule 22 (fator -> ( expr ) .)
    -               reduce using rule 22 (fator -> ( expr ) .)
    ID              reduce using rule 22 (fator -> ( expr ) .)
    INPUT           reduce using rule 22 (fator -> ( expr ) .)
    $end            reduce using rule 22 (fator -> ( expr ) .)
    return          reduce using rule 22 (fator -> ( expr ) .)
    .               reduce using rule 22 (fator -> ( expr ) .)
    )               reduce using rule 22 (fator -> ( expr ) .)
    end             reduce using rule 22 (fator -> ( expr ) .)


state 43

    (6) Func -> ID begin Cod return expr end .

    ID              reduce using rule 6 (Func -> ID begin Cod return expr end .)
    INT             reduce using rule 6 (Func -> ID begin Cod return expr end .)
    INPUT           reduce using rule 6 (Func -> ID begin Cod return expr end .)
    $end            reduce using rule 6 (Func -> ID begin Cod return expr end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
